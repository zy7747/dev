# 一.JS基础

## 1.基本数据类型

| String    | 字符串                   |
| --------- | ------------------------ |
| Number    | 数字                     |
| boolean   | 布尔类型                 |
| Undefined | 变量只有声明，没有赋值   |
| null      | 不确定未来是什么数据类型 |

1. undefined与null的区别，两个都表示什么都没有

* `null == undefined`：成立，他们的值都是空
* `null === undefined`：不成立，他们的值相等但是数据类型不同

.isNaN(数据)：检测一个数据是不是NaN 得到的结果是布尔类型

* 例如：`isNaN('nihao')`,结果为true
* 例如：`isNaN(123)`,结果为false，表示123不是NaN

## 2.typeof关键字

检测一个数据所属的类型

## 3.Math高级数学计算

| abs(x)   | 返回 x 的绝对值        |
| -------- | ---------------------- |
| max(arr) | 数组返回素数组中最大值 |
| min(arr) | 数组返回素数组中最小值 |
| random() | 返回0-1的小数随机数    |
| round(x) | 四舍五入               |

## 4.字符串比较

* 1.字符串比较规则是按照字母的顺序挨个进行比较，与字符串长度无关
* 2.字符串比较区分大小写

```js
	// 字符串的比较是挨个比较对应顺序位置的字母，与长度无关
    console.log('abc' > 'b');				// false，a比d小，所以abc比d小
    
    // 字符串的比较区分大小写，小写大于大写（与ASCII码表对应）
    console.log('a' > 'A');					// true，a对应ASCII码表为97，A为65
```

## 5.window自带方法

```jsx
prompt()//输入框
alert("我的第一个 JavaScript");//警告
document.write()//写入到dom
console.log() //控制台打印
```

## 6.数据类型转换

| parseInt(num)      | 转换数据为整形   |
| ------------------ | ---------------- |
| Number ( "123.1" ) | 转换数据为数值型 |
| 变量名.toString()  | 转换数据为字符串 |
| `Boolean(变量名)`  | 转换数据为布尔型 |
|                    |                  |

## 7.arguemngs关键字

```js
function fn(num1){
	console.log ( arguments );
}
fn(1,2,3)
```

## 8.回调函数

* 1.什么是回调函数：如果一个函数的参数也是一个函数，那么这个参数函数就叫做回调函数
* 2.为什么要有回调函数？
  * 当一个函数调用执行完毕之后，我想执行另一段代码块，也就是调用另一个函数
  * 但是有时候可能本函数执行完毕后，根据不同的情况需要调用的函数也不同，那么我们可以使用形参来接收这个函数，然后再调用
    * 此时：这个形参函数就称之为回调函数

```jsx
function fn(fn2){
    fn2()
	console.log ( 2 );
}
function fn2(){
	console.log ( 1 );
}
fn()
```

## 9.this指向

this是对象内部的变量：代表调用者对象

this : 谁调用我，我就指向谁

```jsx
 sayHi:function(){
                /* 弊端 ： 对象名变化，代码也要修改 */
                // console.log('猴赛雷，我的名字叫' + banzhang.name + '我的年龄是' + banzhang.age );
                console.log('猴赛雷，我的名字叫' + this.name + '我的年龄是' + this.age ); 
            }
```

## 10.便利对象

* 挨个读取对象中的每个属性：属性名和属性值
* 特定语法

```jsx
for(let 属性名变量 in 对象变量){
    //属性名就是对象中的每一个属性
     console.log(key, 对象变量[key]);
}
```

## 11.Date日期对象

| new Date().getDate()          | 从 Date 对象返回一个月中的某一天 (1 ~ 31)                |
| ----------------------------- | -------------------------------------------------------- |
| getDay()                      | 返回值是 0（周日） 到 6（周六） 之间的一个整数。         |
| getFullYear()                 | 表示年份的 4 位数字。                                    |
| getHours()                    | 返回值是 0 （午夜） 到 23 （晚上 11 点）之间的一个整数。 |
| getMonth()                    | 返回值是 0（一月） 到 11（十二月） 之间的一个整数。      |
| Date.parse("March 21, 2012"); | 返回 1970/01/01 至 2012/3/21 之间的毫秒数：              |

## 12.数组对象

| *array*.concat()   | 用于连接两个或多个数组，返回一个新的数组。                   |
| ------------------ | ------------------------------------------------------------ |
| array.filter()     | 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素 |
| *array*.every()    | 方法用于检测数组所有元素是否都符合指定条件如果数组中检测到有一个元素不满足，则整个表达式返回 *false* |
| *array*.includes() | 用来判断一个数组是否包含一个指定的值，如果是返回 true，否则false |
| *array*.indexOf()  | 元素在数组中的位置，如果没有搜索到则返回 -1。                |
| *array*.join()     | 把数组中的所有元素转换为一个字符串：元素是通过指定的分隔符进行分隔的。返回一个新字符串 |
| *array*.map()      | 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。 |
| *array*.push()     | 方法可向数组的末尾添加一个或多个元素，并返回新的长度。       |
| *array*.reduce()   | 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。 |
| *array*.reverse()  | 方法用于颠倒数组中元素的顺序                                 |
| *array*.shift()    | 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值   |
| *array*.slice()    | 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分   |
| *array*.splice()   | 方法用于添加或删除数组中的元素。                             |

## 13.String对象

| *string*.replace(**)        | 一个新的字符串，是用 replacement 替换了 regexp 的第一次匹配或所有匹配之后得到的 |
| --------------------------- | ------------------------------------------------------------ |
| search()                    | 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串 |
| *string*.split(*separator*) | 方法用于把一个字符串分割成字符串数组                         |
| string.trim()               | 方法用于删除字符串的头尾空白符，空白符包括：空格、制表符 tab、换行符等其他空白符等 |
| toLocaleLowerCase()         | 字符串转换为小写                                             |
| toLocaleUpperCase()         | 字符串转换为大写                                             |

## 14.栈和堆

栈**（stack）中主要存放一些**基本类型的变量和对象的引用**其优势是存取速度比堆要快，但缺点是存在栈中的数据大小与生存期必须是确定的，缺乏灵活性，

**堆**（heap 多）用于复杂数据类型（**引用类型**）分配空间，例如数组对象、object对象；它是运行时动态分配内存的，因此存取速度较慢。

## 15.函数的定义

1. 函数声明
2. 函数表达式
3. 构造函数Function

### 函数声明

> 常规的方式

```js
fn();//函数声明可以先调用，在声明
function fn(参数..){
  console.log("这是函数声明")
  return 返回值
}
```



### 函数表达式

```js
const fn = function() {
  console.log("这是函数表达式");  
}
fn();//函数表达式必须先声明，再调用
```

### 构造函数Function

> 函数也可以看成对象

```js

var fn1 = new Function("a1", "a2", "alert(a1+a2)");
fn1(1,2);
```

## 16.原型链和原型



### 原型上存放函数

1. 解决了同一个 `say` 浪费 内存的问题
2. 解决了污染全局变量的问题

```js
   function createStudent(name, age) {
      this.name = name;
    }
    // 将刚才的全局函数say 直接挂载到 构造函数的原型上 即可
    // prototype 是个对象 每一个构造函数都会内置有的. 我们称之为原型
    createStudent.prototype.say = function () {
      console.log(this.name);
    }
```

### 原型

实例的 `proto` 属性 等于 构造函数的 `prototype` 

```js
p1.__proto__ === Person.prototype // true
```

1. 不过由于不同浏览器的兼容性问题,我们`要`使用的时候,都只会使用 构造函数的`prototype`
2. 实例的 proto 只是为了方便我们开发的时候查看数据,是不会手动修改和操作它的。
3. 所有的构造函数都是Function的实例

- 原型的单词是 `prototype`, 原型的这个名字是行业内共同认可的名字。
- 原型本质是一个对象，理解为 `JavaScript` 自动帮我们添加的
- 原型是 `JavaScript` 自动帮我们在`定义构造函数`的时候添加的
- 所有构造函数的实例，共享一个原型
- 原型上一般是挂载函数

17. ## apply 与 call与bind方法

    **call()、apply()、bind() 都是用来重定义 this 这个对象的**

```js
  const RichWumon = {
      name: "富婆",
      say: function () {
        console.log(this.name, " 我要重金求子");
      }
    }

    const obj = {
      name: "屌丝"
    }

    RichWumon.say();			// 富婆
    RichWumon.say.call(obj);	// 屌丝
```

call 、bind 、 apply 这三个函数的第一个参数都是 this 的指向对象，第二个参数差别就来了：

call 的参数是直接放进去的，第二第三第 n 个参数全都用逗号分隔，直接放到后面 **obj.myFun.call(db,'成都', ... ,'string' )**。

apply 的所有参数都必须放在一个数组里面传进去 **obj.myFun.apply(db,['成都', ..., 'string' ])**。

bind 除了返回是函数以外，它 的参数和 call 一样。